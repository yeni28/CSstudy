### B-tree란?
---
B-tree는 자식 2개만을 갖는 이진 트리(Binart Tree)를 확장해 N개의 자식을 가질 수 있도록 고안된 형태이다.
<br>
좌우 자식 간 균형이 맞지 않을 경우에는 매우 비효율적이기 때문에 , 항상 균형을 맞춘다는 의미로 균형트리(Balanced Tree)라고 불린다.
<br>
B-tree는 최상위에 단 하나의 노드만이 존재하는데, 이를  <b>Root Node</b>라고 한다. 그 중간노드를 Branch Node, 최하위 노드를 Leaf Node라고 한다.

### 페이지(page)란?
---
페이지 : 디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위
<br>
일반적인 인덱스를 포함해, PK(클러스터 인덱스)와 테이블은 모두 페이지 단위로 관리된다. 쿼리를 통해 1개 레코드를 읽고 싶을 때, 하나의 블록을 읽어야 하는 것이다. 
<br>

```plain text
+) 블록의 개수는 SQL 성능을 좌우하는 가장 중요한 지표이며, 옵티마이저*의 판단에 가장 큰 영향을 미친다. 블록단위 I/O는 버퍼 캐시와 데이터 파일 I/O 모두에게 적용 된다.


<str>* </str> optimizer : SQL 을 수행할 최적의 처리경로를 생성해주는 DBMS의 핵심엔진

```

따라서 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여, 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 중요하다. 페이지에 저장되는 데이터의 크기가 클수록 디스크 I/O가 많아지고 메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있다. (추가 읽기 작업이 발생할 수 도 있는 것)

### B-tree의 인덱스 구조

인덱스틑 페이지 단위로 저장되며, 인덱스 키를 바탕으로 항상 정렬된 상태를 유지한다. 정렬된 인덱스 키를 따라서 리프 노드에 도달하면 (인덱스 키, PK) 쌍으로 저장되어 있다. 



[인덱스가 필요한 이유]
- 인덱스를 통해 PK를 찾는다.
- PK를 통해 레코드를 찾는다.

하지만, 읽어야 할 레코드의 건 수가 전체  테이블 레코드의 20~25% 이상일 경우 인덱스를 이용하지 않는 것이 효율적이다. 

[인덱스의 컬럼 순서]
- 인덱스는 여러 개의 컬럼으로 구성도리 수 있는데, 이를 다중 컬럼 인덱스라고 부른다.
- 항상 다음 컬럼이 이전 컬럼에 의존하여 정렬된다.

```SQL
CREATE TABLE 'dept_emp'(
    'id' bigint(20) NOT NULL AUTO_INCREMENT,
    'dept_no' varchar(100) NOT NULL,
    'emp_no' varchar(100) NOT NULL,
    INDEX idx_dept_emp('dept_no','emp_no')
    PRIMARY KEY ('id')


)
```

위와 같은 테이블이 있을 때, 두 번쨰 컬럼은 첫 번째 컬럼에 의존해서 정렬된다. 그래서 두 번 째 컬럼만으로 질의하는 경우에는 인덱스를 제대로 이용하지 못한다. 즉, 두 번째 컬럼의 정렬은 첫 번째 컬럼이 동일한 레코드에서만 의미가 있는 것이다. 그래서 인덱스에서 컬럼의 순서가 굉장히 중요하다.














---
- 자료 출처 <br>
(1) 블록과 성능 : https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=360
<br>(2) B-tree와 인덱스 : https://mangkyu.tistory.com/286 


